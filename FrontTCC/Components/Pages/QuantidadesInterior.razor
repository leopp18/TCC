@page "/quantidades-interior"
@using System.Net
@rendermode InteractiveServer

@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Authorization
@using System.Text.Json
@inject IJSRuntime JS
@inject ApiService ApiService
@inject HttpClient Http
@inject AuthenticationStateProvider AuthenticationStateProvider

<PageTitle>Quantidades Interior</PageTitle>

<h1>Quantidades Interior</h1>

<Alert @bind-Visible="showAlert" Color="@alertColor" >
    @alertMessage
    <CloseButton />
</Alert>

@if (permissao == "1" || permissao == "2")
{
    <EditForm Model="filtroPagamento" OnValidSubmit="LoadQuantidades">
        <div class="form-row d-flex justify-content-between">
            <div class="form-group col-md-3 d-flex align-items-center">
                <label class="mr-2"><strong>Mês:</strong></label>
                <InputSelect @bind-Value="filtroPagamento.Mes">
                    <option value="1">Janeiro</option>
                    <option value="2">Fevereiro</option>
                    <option value="3">Março</option>
                    <option value="4">Abril</option>
                    <option value="5">Maio</option>
                    <option value="6">Junho</option>
                    <option value="7">Julho</option>
                    <option value="8">Agosto</option>
                    <option value="9">Setembro</option>
                    <option value="10">Outubro</option>
                    <option value="11">Novembro</option>
                    <option value="12">Dezembro</option>
                </InputSelect>
            </div>
            <div class="form-group col-md-3 d-flex align-items-center">
                <label class="mr-2"><strong>Ano:</strong></label>
                <InputSelect @bind-Value="filtroPagamento.Ano">
                    @foreach (var ano in Enumerable.Range(2024, DateTime.Now.Year - 2023))
                    {
                        <option value="@ano">@ano</option>
                    }
                </InputSelect>
            </div>
            <div class="form-group col-md-3 align-self-end">
                <button type="submit" class="btn btn-primary">Buscar</button>
            </div>
        </div>
    </EditForm>
    <br />
    <Table Striped Bordered Editable>
        <TableHeader ThemeContrast="ThemeContrast.Dark">
            <TableRow>
                <TableHeaderCell class="id-coluna">#</TableHeaderCell>
                <TableHeaderCell class="nome-coluna">Nome</TableHeaderCell>
                <TableHeaderCell class="nome-coluna">Cidade</TableHeaderCell>
                @foreach (var entrega in entregas)
                {
                    <TableHeaderCell class="quantidades-coluna">@entrega.Nome</TableHeaderCell>
                }
                <TableHeaderCell class="quantidades-coluna">Total</TableHeaderCell> 
            </TableRow>
        </TableHeader>
        <TableBody>
            @if (entregadores != null)
            {
                int rowIndex = 1;
                foreach (var entregador in entregadores)
                {
                    <tr @key="entregador.Id">
                        <td><strong>@rowIndex</strong></td>
                        <td>@entregador.Nome @entregador.Sobrenome</td>
                        <td>
                            <Select TValue="int" SelectedValue="@GetCidade(entregador.Id)" SelectedValueChanged="@(async (cidadeId) => await CriarPagamento(entregador.Id, cidadeId))">
                                <option value="0">Selecione uma cidade</option>
                                @foreach (var cidade in cidades)
                                {
                                    <option value="@cidade.Id">@cidade.Nome</option>
                                }
                            </Select>
                        </td>
                        @foreach (var entrega in entregas)
                        {
                            <td @key="entrega.Id">
                                <NumericEdit Plaintext TValue="int" Value="@GetQuantidade(entregador, entrega)" ValueChanged="@(async (valor) => await OnQuantidadeChanged(entregador, entrega, valor))" />
                            </td>
                        }
                        <td><strong>@GetTotalQuantidadeEntregador(entregador)</strong></td> 
                    </tr>
                    rowIndex++;
                }
                <tr>
                    <td colspan="3"><strong>Total</strong></td>
                    @foreach (var entrega in entregas)
                    {
                        <td><strong>@GetTotalQuantidade(entrega)</strong></td>
                    }
                    <td><strong>@GetTotalGeral()</strong></td> 
                </tr>
            }
        </TableBody>
    </Table>
}
else
{
    <p>Você não tem permissão para acessar esta página.</p>
}

@code {
    private List<Entregador> entregadores = new List<Entregador>();
    private List<Entrega> entregas = new List<Entrega>();
    private List<Pagamento> pagamentos = new List<Pagamento>();
    private List<Cidade> cidades = new List<Cidade>();

    private string token = string.Empty;
    private string permissao = string.Empty;

    private FiltroPagamento filtroPagamento = new FiltroPagamento();
    private CancellationTokenSource? debounceCts;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            token = await JS.InvokeAsync<string>("localStorage.getItem", "authToken");
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;

            // Obtenha a permissão do usuário a partir das claims
            permissao = user.FindFirst(c => c.Type == "permissao")?.Value;

            if (permissao == "1" || permissao == "2")
            {
                await LoadCidades();
                await LoadEntregadores();
                await LoadEntregas();
                await LoadQuantidades();
            }

            StateHasChanged(); // Força a atualização do componente após a inicialização
        }
    }

    private async Task LoadEntregadores()
    {
        try
        {
            var todosEntregadores = await ApiService.GetDataAsync<List<Entregador>>("api/Entregador/entregadores", token);

            // Calcular a data correta com base no mês e ano selecionados, sempre dia 01
            DateOnly data = new DateOnly(filtroPagamento.Ano, filtroPagamento.Mes, 01);

            // Obter pagamentos para o mês e ano selecionados
            var pagamentos = await ApiService.GetDataAsync<List<Pagamento>>($"api/Pagamento/pagamentos/{data.ToString("yyyy-MM-dd")}", token);

            // Verificar se a data do filtro é anterior a dois meses
            DateTime dataFiltro = new DateTime(filtroPagamento.Ano, filtroPagamento.Mes, 1);
            DateTime doisMesesAtras = DateTime.Now.AddMonths(-2);

            if (dataFiltro < doisMesesAtras)
            {
                // Incluir entregadores inativos
                entregadores = todosEntregadores.Where(e => !pagamentos.Any(p => p.FkEntregador == e.Id && p.FkCidade == 1)).ToList();
            }
            else
            {
                // Filtrar apenas entregadores ativos
                todosEntregadores = todosEntregadores.Where(e => e.Situacao).ToList();
                entregadores = todosEntregadores.Where(e => !pagamentos.Any(p => p.FkEntregador == e.Id && p.FkCidade == 1)).ToList();
            }
        }
        catch (Exception)
        {
            ShowAlert("Erro ao carregar entregadores", Color.Danger);
        }
    }

    private async Task LoadEntregas()
    {
        try
        {
            entregas = await ApiService.GetDataAsync<List<Entrega>>("api/Entrega/entregas", token);
            entregas = entregas.Where(e => e.Situacao).ToList(); // Filtrar apenas entregas ativas
            entregas = entregas
                .GroupBy(e => e.Nome) // Agrupa por nome
                .Select(g => g.First()) // Seleciona o primeiro item de cada grupo
                .OrderBy(e => e.Nome != "Kms") // Coloca "Kms" por último
                .ThenBy(e => e.Nome)
                .ThenBy(e => e.Valor).ToList();
        }
        catch (Exception)
        {
            ShowAlert("Erro ao carregar entregas", Color.Danger);
        }
    }

    private async Task LoadCidades()
    {
        try
        {
            cidades = await ApiService.GetDataAsync<List<Cidade>>("api/Cidade/cidades", token);
            cidades = cidades.Where(c => c.Id != 1).ToList(); // Excluir cidade com id 1
        }
        catch (Exception)
        {
            ShowAlert("Erro ao carregar cidades", Color.Danger);
        }
    }

    private async Task LoadQuantidades()
    {
        try
        {
            entregadores.Clear();
            await LoadEntregadores();
            Console.WriteLine("Filtro mês: " + filtroPagamento.Mes);
            Console.WriteLine("Filtro ano: " + filtroPagamento.Ano);
            // Calcular a data correta com base no mês e ano selecionados, sempre dia 10
            DateOnly data = new DateOnly(filtroPagamento.Ano, filtroPagamento.Mes, 10);

            // Fazer a requisição para a API com o parâmetro de data
            pagamentos = await ApiService.GetDataAsync<List<Pagamento>>($"api/Pagamento/pagamentos/{data.ToString("yyyy-MM-dd")}", token);

            // Limpar as quantidades antigas
            foreach (var entregador in entregadores)
            {
                entregador.Quantidades?.Clear();
            }

            // Atualizar as quantidades com os novos dados
            foreach (var pagamento in pagamentos)
            {
                var entregador = entregadores.FirstOrDefault(e => e.Id == pagamento.FkEntregador);
                if (entregador != null)
                {
                    var pagamentoEntregas = await ApiService.GetDataAsync<List<PagamentoEntrega>>($"api/PagEnt/pagamentoentrega/pagamento/{pagamento.Id}", token);
                    foreach (var pagamentoEntrega in pagamentoEntregas)
                    {
                        var entrega = entregas.FirstOrDefault(e => e.Id == pagamentoEntrega.FkEntrega);
                        if (entrega != null && entrega.Nome != null)
                        {
                            entregador.Quantidades![entrega.Nome] = pagamentoEntrega.Quantidade;
                        }
                    }
                }
            }
        }
        catch (Exception)
        {
            ShowAlert("Erro ao carregar quantidades", Color.Danger);
        }
    }

    private int GetTotalQuantidade(Entrega entrega)
    {
        return entregadores.Sum(entregador => GetQuantidade(entregador, entrega));
    }

    private int GetTotalQuantidadeEntregador(Entregador entregador)
    {
        return entregador.Quantidades?.Values.Sum() ?? 0;
    }

    private int GetTotalGeral()
    {
        return entregadores.Sum(entregador => GetTotalQuantidadeEntregador(entregador));
    }

    private async Task CriarPagamento(int entregadorId, int cidadeId)
    {
        try
        {
            DateOnly data = new DateOnly(filtroPagamento.Ano, filtroPagamento.Mes, 10);

            // Verificar se o registro de pagamento já existe
            var response = await ApiService.GetDataAsync<Pagamento>($"api/Pagamento/pagamentos/{data.ToString("yyyy-MM-dd")}/{entregadorId}", token);

            if (response == null)
            {
                // Se o pagamento não for encontrado, cria um novo pagamento
                var novoPagamento = new Pagamento
                    {
                        FkEntregador = entregadorId,
                        Periodo = data,
                        FkCidade = cidadeId,
                        Adicional = null,
                        Desconto = null,
                        Adiantamento = null,
                        Pago = false,
                        NotaFiscal = false
                    };

                var createdPagamento = await ApiService.PostDataAsync<Pagamento>("api/Pagamento/pagamentos", JsonContent.Create(novoPagamento), token);
                pagamentos = await ApiService.GetDataAsync<List<Pagamento>>($"api/Pagamento/pagamentos/{data.ToString("yyyy-MM-dd")}", token);
            }
            else
            {
                Console.WriteLine("Pagamento já existe para o entregador e data especificados.");
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            ShowAlert("Erro ao criar pagamento", Color.Danger);
        }
    }

    private async Task SaveQuantidades(Entregador entregador, Entrega entrega, int valor)
    {
        try
        {
            DateOnly data = new DateOnly(filtroPagamento.Ano, filtroPagamento.Mes, 10);

            // Obter o pagamento existente
            var pagamento = pagamentos.FirstOrDefault(p => p.FkEntregador == entregador.Id && p.Periodo == data);
            if (pagamento == null)
            {
                ShowAlert("Erro ao verificar/criar pagamentos", Color.Danger);
                return;
            }

            var pagamentoEntregas = await ApiService.GetDataAsync<List<PagamentoEntrega>>($"api/PagEnt/pagamentoentrega/{data.ToString("yyyy-MM-dd")}", token);

            // Verificar se a quantidade já existe
            var existingPagamentoEntrega = pagamentoEntregas.FirstOrDefault(pe =>
                pe.FkPagamento == pagamento.Id && pe.FkEntrega == entrega.Id && pe.Periodo == data);

            if (existingPagamentoEntrega != null)
            {
                // Atualizar a quantidade existente
                existingPagamentoEntrega.Quantidade = valor;
                await ApiService.PutDataAsync<PagamentoEntrega>($"api/PagEnt/pagamentoentrega/{existingPagamentoEntrega.Id}", JsonContent.Create(existingPagamentoEntrega), token);
            }
            else
            {
                // Criar uma nova quantidade
                var novoPagamentoEntrega = new PagamentoEntrega
                    {
                        FkPagamento = pagamento.Id,
                        FkEntrega = entrega.Id,
                        Quantidade = valor,
                        Periodo = data
                    };
                await ApiService.PostDataAsync<PagamentoEntrega>("api/PagEnt/pagamentoentrega", JsonContent.Create(novoPagamentoEntrega), token);
            }
        }
        catch (Exception ex)
        {
            ShowAlert("Erro ao salvar quantidades", Color.Danger);
        }
    }


    private async Task OnQuantidadeChanged(Entregador entregador, Entrega entrega, int valor)
    {
        int cidadeId = GetCidade(entregador.Id);
        if (cidadeId == 0)
        {
            ShowAlert("ERRO! Selecione uma cidade antes de inserir uma quantidade", Color.Danger);
            return;
        }

        // Atualizar a tabela imediatamente
        if (entrega.Nome != null)
        {
            entregador.Quantidades![entrega.Nome] = valor;
        }

        // Cancelar o token anterior, se existir
        debounceCts?.Cancel();
        debounceCts = new CancellationTokenSource();

        try
        {
            // Aguardar 2 segundos antes de continuar
            await Task.Delay(2000, debounceCts.Token);

            // Se o token não foi cancelado, continuar com a execução
            Console.WriteLine("Valor capturado: " + valor.ToString());

            if (int.TryParse(valor.ToString(), out int quantidade))
            {
                await SaveQuantidades(entregador, entrega, quantidade);
            }
            else
            {
                Console.WriteLine("Valor inválido para quantidade.");
            }
        }
        catch (TaskCanceledException)
        {
            // Ignorar a exceção se a tarefa foi cancelada
        }
    }

    private int GetQuantidade(Entregador entregador, Entrega entrega)
    {
        if (entrega.Nome != null && entregador.Quantidades != null)
        {
            return entregador.Quantidades.TryGetValue(entrega.Nome, out var quantidade) ? quantidade : 0;
        }
        return 0;
    }

    private int GetCidade(int entregadorId)
    {
        try
        {
            DateOnly data = new DateOnly(filtroPagamento.Ano, filtroPagamento.Mes, 10);
            int cidade = 0;

            // Fazer a requisição para a API com o parâmetro de data e entregador
            var pagamentos = ApiService.GetData<List<Pagamento>>($"api/Pagamento/pagamentos/{data.ToString("yyyy-MM-dd")}/{entregadorId}", token);

            if (pagamentos != null)
            {
                cidade = pagamentos.FirstOrDefault()?.FkCidade ?? 0;
                return cidade;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erro ao obter cidade: {ex.Message}");
        }
        return 0;
    }


    private bool showAlert = false;
    private string alertMessage = string.Empty;
    private Color alertColor = Color.Primary;

    private void ShowAlert(string message, Color color)
    {
        alertMessage = message;
        alertColor = color;
        showAlert = true;
    }

    public class Entregador
    {
        public int Id { get; set; }
        public string? Nome { get; set; }
        public string? Sobrenome { get; set; }
        public string? Pix { get; set; }
        public bool Situacao { get; set; }
        public Dictionary<string, int>? Quantidades { get; set; } = new Dictionary<string, int>();
    }

    public class Entrega
    {
        public int Id { get; set; }
        public string? Nome { get; set; }
        public decimal Valor { get; set; }
        public bool Situacao { get; set; }
    }

    public class FiltroPagamento
    {
        public int Mes { get; set; } = DateTime.Now.Month;
        public int Ano { get; set; } = DateTime.Now.Year;
    }

    public class Pagamento
    {
        public int Id { get; set; }
        public decimal? Adicional { get; set; }
        public decimal? Desconto { get; set; }
        public decimal? Adiantamento { get; set; }
        public bool? Pago { get; set; }
        public bool? NotaFiscal { get; set; }
        public int FkCidade { get; set; }
        public int FkEntregador { get; set; }
        public DateOnly Periodo { get; set; }
    }

    public class PagamentoEntrega
    {
        public int Id { get; set; }
        public int Quantidade { get; set; }
        public int FkEntrega { get; set; }
        public int FkPagamento { get; set; }
        public DateOnly Periodo { get; set; }
    }

    public class Cidade
    {
        public int Id { get; set; }
        public string? Nome { get; set; }
        public int FkEstado { get; set; }
    }

    public class PagamentoNaoEncontradoException : Exception
    {
        public PagamentoNaoEncontradoException(string message) : base(message) { }
    }
}
